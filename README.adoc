// INSTRUCTION: Please remove all comments that start INSTRUCTION prior to commit. Most comments should be removed, although not the copyright.
// INSTRUCTION: The copyright statement must appear at the top of the file
//
// Copyright (c) 2017 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: istio
:page-layout: guide
:page-duration: 30 minutes
:page-releasedate: 2018-06-30
:page-description: Explore how to route traffic to different versions of the same service using Istio and Kubernetes.
:page-tags: ['microservices', '{kube}', 'Docker', 'containers', 'kubectl', 'Minikube', 'istio']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker', 'kubernetes']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
= Routing traffic with Istio

Explore how to route traffic to different versions of the same service using Istio and Kubernetes.

:minikube-ip: 192.168.99.100
:kube: Kubernetes
:istio: Istio


== What you'll learn

You will learn how to deploy an application to a kubernetes cluster using {istio} and how to configure
{istio} to route http requests based on the content of the headers.

The two microservices that you will deploy are called `name` and `ping`, they are provided for you under
the `start` directory. The `name` service displays a brief gretting, and the `ping` microservice pings the
`name` service. You will modify the name service so that it can easily be configured to display
a different greeting.

You will use Minikube as your local {kube} cluster. You will use {istio}'s Ingress, and the `istioctl`
cli tool to deploy your application as well as configure the routing.

// =================================================================================================
// What is {istio}
// =================================================================================================

== What is {istio}?

{istio} is a platform that provides several features that allow you manage various aspects
of how your microservices interact with eachother and the outside world. It works by deploying
a few extra services and injecting an additional container into each of your pods that contains
the https://www.envoyproxy.io/[Envoy] proxy.

While {istio} supports {kube} and that will be the focus of this guide, please note that {istio}
can also be used with other environments.

=== Why use {istio}?

{istio} provides a collection of features that allow you to several aspects of your services
such as: Routing, Logging, and Security. These features can easily be enabled by applying the appropriate
{istio} files to your {kube} cluster. This guide will specifically focus on routing.

// =================================================================================================
// Prerequisites
// =================================================================================================

== Prerequisites

// Before you begin, make sure to have the following tools installed:

// - `kubernetes-cli` - a command line interface for {kube} called `kubectl`. This is your primary
// tool for communicating with and managing your {kube} cluster.
// - `kubernetes-helm` - a package manager for {kube} called Helm. Helm allows you to install packages
// or "charts", which are sets of preconfigured {kube} resources. Installing charts is much more
// convenient than creating and configuring the resources yourself.
// - `minikube` - a local, single-node {kube} cluster that runs in a virtual machine.

// Finally, you will need a containerization software for building containers. {kube} supports a variety
// of container types and while you're not limited to any of them in particular, you should use Docker
// as this is what this guide will focus on.


Before you being, make sure to have the following tools installed:

- `kubernetes-cli` - a command line interface for {kube} called `kubectl`. This is your primary
tool for communicating with and managing your {kube} cluster.
- `minikube` - a local, single-node {kube} cluster that runs in a virtual machine.
- `istioctl` - a command line interface for {istio} to deploy {istio} to your {kube} cluster
and to manage your {istio} configurations. Installation instructions can be found here:  https://istio.io/docs/setup/kubernetes/quick-start/

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.

// =================================================================================================
// Staring and preparing your cluster for Deployment
// =================================================================================================

== Starting and preparing your cluster for Deployment

You must start Minikube with these flags to use {istio}:

```
# Unix
minikube start \
    --extra-config=controller-manager.ClusterSigningCertFile="/var/lib/localkube/certs/ca.crt" \
    --extra-config=controller-manager.ClusterSigningKeyFile="/var/lib/localkube/certs/ca.key" \
    --extra-config=apiserver.Admission.PluginNames=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota

# Windows
minikube start ^
    --bootstrapper=localkube ^
    --vm-driver=hyperv ^
    --hyperv-virtual-switch=minikube-virtual-switch ^
    --extra-config=controller-manager.ClusterSigningCertFile="/var/lib/localkube/certs/ca.crt" ^
    --extra-config=controller-manager.ClusterSigningKeyFile="/var/lib/localkube/certs/ca.key" ^
    --extra-config=apiserver.Admission.PluginNames=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
```

Run this command to connect the Docker CLI to use Minikube's Docker Daemon:
```
# From Bash if you're on Linux or MacOS
eval $(minikube docker-env)
# From PowerShell or CMD if you're on Windows
minikube docker-env > tmp.cmd && call tmp.cmd && DEL tmp.cmd
```

Next, you must deploy {istio} to your cluster. From the directory where you installed {istio}, run the following command:
```
kubectl apply -f install/kubernetes/istio.yaml
```
If you observe any errors, run the command one more time and it should succeed without any errors.

You can verify that it was successful by running the following command to ensure that {istio} was deployed:
```
kubectl get pods -n istio-system
```


// =================================================================================================
// Deploying v1 of the services to cluster
// =================================================================================================

== Deploying v1 of the services to cluster

To deploy the services to the {kube} cluster, run the following commands from the `start` directory:
```
# Unix
kubectl apply -f <(istioctl kube-inject -f kubernetes.yaml)
# Windows
istioctl kube-inject -f kubernetes.yaml > tmp.yaml
kubectl apply -f tmp.yaml
DEL tmp.yaml
```

This will inject the sidecar containers into your configuration so that the Envoy proxy
is deployed with each of your pods.

To get the base url, use the following command:
```
minikube service list | grep istio-ingress | awk "{ print $6 }"
```

This command will result in a url of the form `http://ip-address:port`.

Once all the pods are started, you should be able to navigate to `http://ip-address:port/inventory/systems` to view
v1 of the deployed application.

// =================================================================================================
// Testing microservices that are running on {kube}
// =================================================================================================


// =================================================================================================
// Modify the service
// =================================================================================================

== Modify and deploy v2 of the service

Rename the `getTotal()` method in `inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java` to `getCount()`:

[source, Java]
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/InventoryResource.java[tags=**;!copyright;]
----

This introduces a breaking change to the REST service because now the response will look like:
```
{
    "systems": [],
    "count": 0
}
```

instead of:

```
{
    "systems": [],
    "total": 0
}
```

Therefore, anyone clients consuming the service will now be broken since they are expecting a property called
`total` instead of `count`. To solve this, we can actually have both versions of the service deployed
and decide which one to use by having a header distinguish which version to use.

To update the version of your service, run the following command in the `inventory` directory:

```
mvn versions:set -DnewVersion=2.0-SNAPSHOT
```

Rebuild the service using the following command in the `inventory` directory:
```
mvn package
```

Update the `kubernetes.yaml` file to add a new deployment:

[source, yaml]
----
include::finish/kubernetes.yaml[tags=**;!copyright;]
----

Redeploy your services using the following commands:
```
# Unix
kubectl apply -f <(istioctl kube-inject -f kubernetes.yaml)
# Windows
istioctl kube-inject -f kubernetes.yaml > tmp.yaml
kubectl apply -f tmp.yaml
DEL tmp.yaml
```

Make a request to the service and observe that requests go to both v1 and v2.

// =================================================================================================
// Configure request routing
// =================================================================================================

== Configure request routing

Create the file `routing.yaml` in the `start` directory:

[source, yaml]
----
include::finish/routing.yaml[tags=**;!copyright;]
----

* Explanation of what the file does
* `istioctl create -f routing.yaml` to apply routing rules
* Make a request `curl http://ip-address:port/api/name -H "x-version: v2"`, observe that request goes to v2 of the service
* Make a request `curl http://ip-address:port/api/name`, observe that request default to v1 of the service


== Testing microservices that are running on {kube}

Run the following command to start the tests:

```
mvn verify -Ddockerfile.skip=true -Dtest.ip=ip-address -Dtest.port=port
```

// =================================================================================================
// finish
// =================================================================================================

== Great work! You're done!

You have deployed to services to {kube} and routed requests to different versions of the `inventory` service based on
http headers.

// uncomment this when Istio guide is released
//Feel free to check out our https://github.com/OpenLiberty/guide-istio[Istio guide], which builds on top of what you learned here.

// Include the below from the guides-common repo to tell users how they can contribute to the guide
include::{common-includes}/finish.adoc[]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"

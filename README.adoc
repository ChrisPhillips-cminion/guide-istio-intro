// INSTRUCTION: Please remove all comments that start INSTRUCTION prior to commit. Most comments should be removed, although not the copyright.
// INSTRUCTION: The copyright statement must appear at the top of the file
//
// Copyright (c) 2017 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: istio
:page-layout: guide
:page-duration: 15 minutes
:page-releasedate: 2018-06-30
:page-description: Explore how to route traffic to different versions of the same service using Istio and Kubernetes.
:page-tags: ['microservices', 'Kubernetes', 'Docker', 'containers', 'kubectl', 'Minikube', 'Istio']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker', 'kubernetes']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
:page-seo-title: Istio routing tutorial
:page-seo-description: How to run microservices in Istio
= Versioning services with Istio

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Explore how to leverage content-based routing to route HTTP traffic to different versions of the same service using Istio and Kubernetes.

:kube: Kubernetes
:istio: Istio
:win: WINDOWS
:mac: MAC
:linux: LINUX


== What you'll learn

You will learn how to deploy an application to a Kubernetes cluster and enable {istio} on it. You will also learn how to configure
{istio} to shift traffic to implement blue-green deployments.

The microservice that you will deploy is called `hello`. It responds with a JSON object containing a version number and a greeting.

You will use the `kubectl` CLI tool to deploy and manage your {kube} resources. You will use the `istioctl` CLI tool to inject {istio} sidecars into your pods.

=== What is {istio}?

{istio} is a platform for managing how microservices interact with each other as well as the outside world.
It works by deploying istio control plane and injecting an additional container into each of your pods that contains
the https://www.envoyproxy.io/[Envoy] proxy. You can think of Envoy as a sidecar that intercepts and controls all the traffic to and from your container. It is specialized for a service mesh architecture since it offers useful features
such as load balancing and support for distributed tracing.

While {istio} supports {kube} and that will be the focus of this guide, note that {istio}
can also be used with other environments such as Docker Compose. {istio} has many features, some of them are
traffic shifting, request routing, access control, and distributed tracing. The focus of this guide will be traffic shifting.

=== Why {istio}?

{istio} provides a collection of features that allow you to manage several aspects of your services
such as: Routing, Telemetry, and Security. These features can be easily configured independently of your
application's code.

A possible use case for {istio}'s Telemetry feature can be to enable distributed tracing which allows you
to visualize how HTTP requests travel between different services in your cluster using a tool such as https://zipkin.io/[Zipkin].
One of the items {istio} offers under its collection of security features is to enable HTTPS between pods
in your cluster to secure communication internally.

You will use {istio}'s traffic shifting features to implement blue-green deployments.

// =================================================================================================
// Prerequisites
// =================================================================================================

include::{common-includes}/kube-prereq.adoc[]

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.

// =================================================================================================
// Staring and preparing your cluster for deployment
// =================================================================================================

:minikube-start: minikube start --memory=8192 --cpus=4 --kubernetes-version=v1.10.0
include::{common-includes}/kube-start.adoc[]

// =================================================================================================
// Deploying Istio
// =================================================================================================

== Deploying Istio

First, go to the https://github.com/istio/istio/releases[{istio} release page] and download the latest stable release. Extract the archive and navigate to the directory containing the extracted files. Add the `bin/` directory to your `PATH`.

****
[system]#*{linux} | {mac}*#

```
cd bin
export PATH=$PATH:$PWD
cd ..
```

[system]#*{win}*#

```
cd bin
set PATH=%PATH%;%cd%
cd ..
```
****

Next, deploy the {istio} custom resource definitions. Custom resource definitions allows {istio} to define custom {kube} resources that you can use in your resource definition files.

```
kubectl apply -f install/kubernetes/helm/istio/templates/crds.yaml
```

Next, deploy {istio}'s resources to your cluster by running the `kubectl apply` command, which creates or updates
{kube} resources defined in a yaml file. This command will deploy {istio}.

```
kubectl apply -f install/kubernetes/istio-demo.yaml
```

Verify that {istio} was successfully deployed. All the values in the `AVAILABLE` column will have a value of `1` once
the deployment is complete.

```
kubectl get deployments -n istio-system
```
 
Ensure that the istio deployments are all available before continuing, it may take a few minutes for all of them to be available.
[source, role="no_copy"]
----
NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
grafana                  1         1         1            1           44s
istio-citadel            1         1         1            1           44s
istio-egressgateway      1         1         1            1           44s
istio-galley             1         1         1            1           44s
istio-ingressgateway     1         1         1            1           44s
istio-pilot              1         1         1            1           44s
istio-policy             1         1         1            1           44s
istio-sidecar-injector   1         1         1            1           44s
istio-telemetry          1         1         1            1           44s
istio-tracing            1         1         1            1           43s
prometheus               1         1         1            1           44s
servicegraph             1         1         1            1           44s
----

// =================================================================================================
// Deploying v1 of the service to cluster
// =================================================================================================

== Deploying version 1 of the service to the cluster

Navigate to the `start` directory and run the following command, it may take a few minutes to build.
It will build the application and then package it into a docker image.
To build the docker image it uses a maven plugin called `dockerfile-maven-plugin`.

```
mvn clean package
```

After running the command, it builds a docker image for the `hello` microservice.
You can verify that this image was created by running the given command. 

```
docker images
```

You will see image called `hello:1.0-SNAPSHOT` listed in a table similar to the output.

[source, role="no_copy"]
----
REPOSITORY                                 TAG                 IMAGE ID            CREATED             SIZE
hello                                      1.0-SNAPSHOT        d316c2c2c6ba        9 seconds ago       501MB
istio/galley                               1.0.1               7ac6c7be3d3e        5 days ago          65.8MB
istio/citadel                              1.0.1               abcc721c2454        5 days ago          51.7MB
istio/mixer                                1.0.1               0d97b4000ed5        5 days ago          64.5MB
istio/sidecar_injector                     1.0.1               a122adc160b7        5 days ago          45.3MB
istio/proxyv2                              1.0.1               f1bf7b920fe1        5 days ago          352MB
istio/pilot                                1.0.1               46d3b4e95fc3        5 days ago          290MB
open-liberty                               latest              ed1ca62c4bd5        7 days ago          501MB
prom/prometheus                            v2.3.1              b82ef1f3aa07        2 months ago        119MB
----

To deploy the `hello` microservice to the {kube} cluster, run the command:

****
[system]#*{linux} | {mac}*#

```
istioctl kube-inject -f hello.yaml | kubectl apply -f -
```

[system]#*{win}*#

```
istioctl kube-inject -f hello.yaml > tmp-hello.yaml
kubectl apply -f tmp-hello.yaml
del tmp-hello.yaml
```
****

You can see that your resources are created:

[source, role="no_copy"]
----
gateway.networking.istio.io/hello-gateway created
service/hello-service created
deployment.apps/hello-deployment-blue created
deployment.apps/hello-deployment-green created
----

The `traffic.yaml` file contains two virtual services and a destination rule. A virtual service defines how requests are routed to your applications through the gateway. A destination rule is used to apply policies post-routing, in this situation it is used to define service subsets that can be specifically routed to. Deploy the resources defined in `traffic.yaml`.

```
kubectl apply -f traffic.yaml
```

[source, role="no_copy"]
----
virtualservice.networking.istio.io/hello-virtual-service created
virtualservice.networking.istio.io/hello-test-virtual-service created
destinationrule.networking.istio.io/hello-destination-rule created
----

Once all the deployments are available, you should be able to navigate to make a request to `\http://<ip-address>:<port>/hello` to view
v1 of the deployed application, as defined in `hello.yaml` the gateway is expecting the host to be `example.com` so ensure to set the `Host` header appropriately.

You can check that all of the deployments are available using the command.

```
kubectl get deployments
```

Which produces a list of deployments for your microservices.

[source, role="no_copy"]
----
NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
hello-deployment-blue    1         1         1            1           1m
hello-deployment-green   1         1         1            1           1m
----

****
[system]#*{win} | {mac}*#

Make a request to the service by using curl. If curl is unavailable then use https://www.getpostman.com/[Postman].

```
curl -HHost:example.com http://localhost/hello
```

[system]#*{linux}*#

Make a request to the service by using curl.

```
curl -HHost:example.com http://`minikube ip`:31380/hello
```
****

// =================================================================================================
// Deploy v2
// =================================================================================================

== Deploying version 2 of the hello microservice

The `hello` microservice is setup to respond with the version that is set in the `pom.xml` file. The tag for the docker image is also dependant on the version specified in the `pom.xml` file. Use the maven command to bump the version of the microservice to `2.0-SNAPSHOT`.

```
mvn versions:set -DnewVersion=2.0-SNAPSHOT
```

Build the new version of the docker container.

```
mvn clean package
```

Deploy the new image to the green deployment.

```
kubectl set image deployment/hello-deployment-green hello-container=hello:2.0-SNAPSHOT
```

Test the updated microservice by making requests to the testing site. The `version` field in the response JSON is now `2.0-SNAPSHOT` on the testing site and it is still `1.0-SNAPSHOT` on the live site.

****
[system]#*{win} | {mac}*#

Make a request to the service by using curl. If curl is unavailable then use https://www.getpostman.com/[Postman].

```
curl -HHost:test.example.com http://localhost/hello
```

[system]#*{linux}*#

Make a request to the service by using curl.

```
curl -HHost:test.example.com http://`minikube ip`:31380/hello
```
****

Once you see that the microservice is working on the testing site, modify the `traffic.yaml` file to shift 100% of the live traffic to the green deployment.

[source, Java]
----
include::finish/traffic.yaml[tags=**;]
----

Deploy the updated `traffic.yaml` file.

```
kubectl apply -f traffic.yaml
```

Ensure that the live traffic is now being routed to version 2 of the microservice.

****
[system]#*{win} | {mac}*#

Make a request to the service by using curl. If curl is unavailable then use https://www.getpostman.com/[Postman].

```
curl -HHost:example.com http://localhost/hello
```

[system]#*{linux}*#

Make a request to the service by using curl.

```
curl -HHost:example.com http://`minikube ip`:31380/hello
```
****

// =================================================================================================
// Deploy v3
// =================================================================================================

== Automating the blue-green switch

Manually changing the weights in the `traffic.yaml` to deploy a new version of your microservice can be a tedious process. Thankfully this can be easily automated with some scripting. You'll deploy version 3 of the `hello` microservice and create a script to automate the switch over. Use the maven command to bump the version of the microservice to `3.0-SNAPSHOT`.

```
mvn versions:set -DnewVersion=3.0-SNAPSHOT
```

Build the new version of the docker container.

```
mvn clean package
```

Deploy the new image to the blue deployment.

```
kubectl set image deployment/hello-deployment-blue hello-container=hello:3.0-SNAPSHOT
```

Test the updated microservice by making requests to the testing site. You will see the `version` field of the JSON response is equal to `3.0-SNAPSHOT`.

****
[system]#*{win} | {mac}*#

Make a request to the service by using curl. If curl is unavailable then use https://www.getpostman.com/[Postman].

```
curl -HHost:test.example.com http://localhost/hello
```

[system]#*{linux}*#

Make a request to the service by using curl.

```
curl -HHost:test.example.com http://`minikube ip`:31380/hello
```
****

Once you see that the microservice is working on the testing site, you will create a script to automate shifting the traffic.

****
[system]#*{mac} | {linux}*#

Create the `set-live` file.

[source, bash]
----
include::finish/set-live[tags=**;]
----

Make the `set-live` file executable.

```
chmod +x set-live
```

Move the live traffic over to the blue deployment.

```
./set-live blue
```

[system]#*{win}*#

Create the `set-live.bat` file.

[source, batch]
----
include::finish/set-live.bat[tags=**;]
----

Move the live traffic over to the blue deployment.

```
set-live.bat blue
```
****

Ensure that the live traffic is now being routed to version 3 of the microservice.

****
[system]#*{win} | {mac}*#

Make a request to the service by using curl. If curl is unavailable then use https://www.getpostman.com/[Postman].

```
curl -HHost:example.com http://localhost/hello
```

[system]#*{linux}*#

Make a request to the service by using curl.

```
curl -HHost:example.com http://`minikube ip`:31380/hello
```
****

The `set-live` script generates its own `traffic.yaml` contents with the appropriate weights substituted in to route live traffic to either the blue or green deployment. Then it deploys the updated virtual services to route traffic accordingly.

== Testing microservices that are running on {kube}

Create the endpoint test in the `src/test/java/it/io/openliberty/guides/rest/EndpointTest.java` file:
[source, Java]
----
include::finish/src/test/java/it/io/openliberty/guides/rest/EndpointTest.java[tags=**;!copyright]
----

The `testGetGreeting` test case verifies that the correct greeting and version number are returned from the rest service.

****
[system]#*{win} | {mac}*#

Run the command to start the tests:

```
mvn verify -Ddockerfile.skip=true
```

[system]#*{linux}*#

Run the command to start the tests:

```
mvn verify -Ddockerfile.skip=true -Dcluster.ip=`minikube ip` -Dport=31380
```
****

The `dockerfile.skip=true` flag skips re-building the docker images. The `cluster.ip` and `port`
parameters refer to the ip address and port for the {istio} gateway.

If the tests pass, then you should see output similar to this:

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.rest.EndpointTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.648 s - in it.io.openliberty.guides.rest.EndpointTest

Results:

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

Roll back to the old version of the microservice and run the tests again.

****
[system]#*{mac} | {linux}*#

```
./set-live green
```

[system]#*{win}*#

```
set-live.bat green
```
****

****
[system]#*{win} | {mac}*#

Run the command to start the tests:

```
mvn verify -Ddockerfile.skip=true
```

[system]#*{linux}*#

Run the command to start the tests:

```
mvn verify -Ddockerfile.skip=true -Dcluster.ip=`minikube ip` -Dport=31380
```
****

Observe that the tests fail because the version number that the tests expect and the version of the running microservice are now different. 

== Tearing down your environment

Finally, you may want to teardown all the deployed resources as a cleanup step.

Delete your resources from the cluster.
```
kubectl delete -f hello.yaml
kubectl delete -f traffic.yaml
```

Navigate to the directory where you extracted {istio} and delete the {istio} resources from the cluster.
```
kubectl delete -f install/kubernetes/istio-demo.yaml
kubectl delete -f install/kubernetes/helm/istio/templates/crds.yaml
```

include::{common-includes}/kube-minikube-teardown.adoc[]

// =================================================================================================
// finish
// =================================================================================================

== Great work! You're done!

You have deployed a microservice to a Kubernetes cluster and used Istio to implement a blue-green deployment scheme.

// uncomment this when Istio guide is released
//Feel free to check out our https://github.com/OpenLiberty/guide-istio[Istio guide], which builds on top of what you learned here.

// Include the below from the guides-common repo to tell users how they can contribute to the guide
include::{common-includes}/finish.adoc[]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"

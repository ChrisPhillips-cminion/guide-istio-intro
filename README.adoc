// INSTRUCTION: Please remove all comments that start INSTRUCTION prior to commit. Most comments should be removed, although not the copyright.
// INSTRUCTION: The copyright statement must appear at the top of the file
//
// Copyright (c) 2017 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//

NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/istio.html[Open Liberty website]

:projectid: istio
:page-layout: guide
:page-duration: 30 minutes
:page-releasedate: 2018-06-30
:page-description: Explore how to route traffic to different versions of the same service using Istio and Kubernetes.
:page-tags: ['microservices', '{kube}', 'Docker', 'containers', 'kubectl', 'Minikube', 'istio']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker', 'kubernetes']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
//:link-to-published-guide: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].
= Versioning services with Istio

// [.hidden]
// NOTE: {link-to-published-guide}

Explore how to route traffic to different versions of the same service using Istio and Kubernetes.

:minikube-ip: 192.168.99.100
:kube: Kubernetes
:istio: Istio


== What you'll learn

You will learn how to deploy an application to a kubernetes cluster using {istio} and how to configure
{istio} to route http requests based on the content of the headers.

The two microservices that you will deploy are called `inventory` and `system`, they are provided for you under
the `start` directory. The `inventory` service stores information about systems that are running the `system` service.

You will use Minikube as your local {kube} cluster. You will use {istio}'s Ingress, and the `istioctl`
cli tool to deploy your application as well as configure the routing.

=== What is {istio}?

{istio} is a platform that provides several features that allow you manage various aspects
of how your microservices interact with each other and the outside world. It works by deploying
a few extra services and injecting an additional container into each of your pods that contains
the https://www.envoyproxy.io/[Envoy] proxy.

While {istio} supports {kube} and that will be the focus of this guide, please note that {istio}
can also be used with other environments.

=== Why use {istio}?

{istio} provides a collection of features that allow you to manage several aspects of your services
such as: Routing, Logging, and Security. These features can be easilyconfigured independently of your
application's code.

// =================================================================================================
// Prerequisites
// =================================================================================================

== Prerequisites

Before you begin, make sure to have the following tools installed:

- `kubernetes-cli` - a command line interface for {kube} called `kubectl`. This is your primary
tool for communicating with and managing your {kube} cluster.
- `minikube` - a local, single-node {kube} cluster that runs in a virtual machine.
- `istioctl` - a command line interface for {istio} to deploy {istio} to your {kube} cluster
and to manage your {istio} configurations. Installation instructions can be found here: https://istio.io/docs/setup/kubernetes/quick-start/#download-and-prepare-for-the-installation
- `helm` - a package manager for kubernetes, installation instructions can be found here: https://docs.helm.sh/using_helm/#installing-helm

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.

// =================================================================================================
// Staring and preparing your cluster for Deployment
// =================================================================================================

== Starting and preparing your cluster for Deployment

Start Minikube with these flags to use {istio}:

Unix:
```
minikube start \
    --extra-config=controller-manager.ClusterSigningCertFile="/var/lib/localkube/certs/ca.crt" \
    --extra-config=controller-manager.ClusterSigningKeyFile="/var/lib/localkube/certs/ca.key" \
    --extra-config=apiserver.Admission.PluginNames=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
```

Windows:
```
minikube start ^
    --bootstrapper=localkube ^
    --vm-driver=hyperv ^
    --hyperv-virtual-switch=minikube-virtual-switch ^
    --extra-config=controller-manager.ClusterSigningCertFile="/var/lib/localkube/certs/ca.crt" ^
    --extra-config=controller-manager.ClusterSigningKeyFile="/var/lib/localkube/certs/ca.key" ^
    --extra-config=apiserver.Admission.PluginNames=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
```

Running the `minikube start ...` command will create and start a virtual machine that will be used
for a local kubernetes cluster. The extra flags are needed for minikube to work correctly
with {istio}.

Run this command to connect the Docker CLI to use Minikube's Docker Daemon:

Unix:
```
eval $(minikube docker-env)
```

Windows:
```
minikube docker-env > tmp.cmd && call tmp.cmd && DEL tmp.cmd
```

As a result of this command, if you issue docker commands they will affect the docker environment
in the Minikube VM rather than the one you likely have installed on your computer.

First, prepare your {istio} deployment using Helm:
```
helm template path/to/istio/install/kubernetes/helm/istio --name istio --namespace istio-system --set sidecarInjectorWebhook.enabled=false > istio.yaml
```

Next, create the `istio-system` namespace:
```
kubectl create namespace istio-system
```

You can think of the `istio-system` namespace as a place to keep all of the
{istio} resources in your cluster separate from the rest of your deployments and services.
If you desire, then you can similarly create a namespace for the resources we'll be deploying later.
If no namespace is specified it will use the `default` namespace by default.

Next, deploy {istio} to your cluster.
```
kubectl apply -f istio.yaml
```
If you observe any errors, run the command one more time and it should succeed without any errors.

Verify that {istio} was successfully deployed.
```
kubectl get deployments -n istio-system
```
 
Ensure that the istio deployments are all available before continuing, it may take a few minutes for all of them to be available.
[source, role="no_copy"]
----
NAME                       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
istio-citadel              1         1         1            1           5m
istio-egressgateway        1         1         1            1           5m
istio-ingress              1         1         1            1           5m
istio-ingressgateway       1         1         1            1           5m
istio-pilot                1         1         1            1           5m
istio-policy               1         1         1            1           5m
istio-statsd-prom-bridge   1         1         1            1           5m
istio-telemetry            1         1         1            1           5m
prometheus                 1         1         1            1           5m
----

// =================================================================================================
// Deploying v1 of the services to cluster
// =================================================================================================

== Deploying version 1 of the services to cluster

Navigate to the `start` directory and run the following command, it may take a few minutes to build:
```
mvn clean package
```

After running the command, it should build a docker image for the `inventory` service and an image for the `system` service.
You can verify that these images were created by running the command `docker images` and you should see images called
`inventory-service:1.0-SNAPSHOT` and `system-service:1.0-SNAPSHOT`.

[source, role="no_copy"]
----
REPOSITORY                                TAG                 IMAGE ID            CREATED              SIZE
inventory-service                         1.0-SNAPSHOT        b90385c20c52        7 seconds ago        487MB
system-service                            1.0-SNAPSHOT        498fe1db2e75        About a minute ago   487MB
prom/prometheus                           latest              b82ef1f3aa07        2 days ago           119MB
open-liberty                              latest              ba15c5b7d54d        2 weeks ago          487MB
istio/citadel                             0.8.0               3d382d44e0b9        2 weeks ago          51.1MB
istio/mixer                               0.8.0               c5237a3d27ac        2 weeks ago          60.6MB
istio/proxyv2                             0.8.0               a43f156372a7        2 weeks ago          291MB
istio/proxy                               0.8.0               25195d33b0b3        2 weeks ago          174MB
istio/pilot                               0.8.0               8c69f3b2ff64        2 weeks ago          286MB
k8s.gcr.io/kube-addon-manager             v8.6                9c16409588eb        4 months ago         78.4MB
prom/statsd-exporter                      latest              304735eab4e4        5 months ago         14.1MB
k8s.gcr.io/pause-amd64                    3.1                 da86e6ba6ca1        6 months ago         742kB
k8s.gcr.io/kubernetes-dashboard-amd64     v1.8.1              e94d2f21bc0c        6 months ago         121MB
gcr.io/k8s-minikube/storage-provisioner   v1.8.1              4689081edb10        7 months ago         80.8MB
k8s.gcr.io/k8s-dns-sidecar-amd64          1.14.5              fed89e8b4248        8 months ago         41.8MB
k8s.gcr.io/k8s-dns-kube-dns-amd64         1.14.5              512cd7425a73        8 months ago         49.4MB
k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64    1.14.5              459944ce8cc4        8 months ago         41.4MB
quay.io/coreos/hyperkube                  v1.7.6_coreos.0     2faf6f7a322f        9 months ago         699MB
----

To deploy the services to the {kube} cluster, run the following commands:

Unix:
```
kubectl apply -f <(istioctl kube-inject -f kubernetes.yaml)
```

Windows:
```
istioctl kube-inject -f kubernetes.yaml > tmp.yaml
kubectl apply -f tmp.yaml
DEL tmp.yaml
```

The `kubernetes.yaml` file defines some resources including two deployments, two services, and an ingress.

|=========================
| gateway | An Ingress that will route traffic to your services
| inventory-service | Stores information about systems that are running system-service
| inventory-deployment-v1 | Contains the containers that will run version 1 of the inventory application
| system-service | Responds with information about the system that the service is running on
| system-deployment | Contains the containers responsible for system-service
|=========================

By using the command `istioctl kube-inject -f kubernetes.yaml`, it prints a modified version
of the `kubernetes.yaml` file to stdout containing any modifications needed by {istio} such as adding
{istio}'s envoy containers.

You can see that your resources are created after running the `kubectl apply -f ...` command:

[source, role="no_copy"]
----
ingress "gateway" created
service "inventory-service" created
deployment "inventory-deployment-v1" created
service "system-service" created
deployment "system-deployment" created
----

To get the base url, use the following command:
```
minikube service list | grep istio-ingress | head -1 | awk '{ print $6 }'
```

This command will give you a url of the form `http://ip-address:port`.

Once all the deployments are available, you should be able to navigate to `http://ip-address:port/inventory/systems` to view
v1 of the deployed application.

You can check that all of the deployments are available using the command `kubectl get deployments`.

[source, role="no_copy"]
----
NAME                      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
inventory-deployment-v1   1         1         1            1           1m
system-deployment         1         1         1            1           1m
----

// =================================================================================================
// Modify the service
// =================================================================================================

== Modify and deploy version 2 of the service

Rename the `getTotal()` method in `inventory/src/main/java/io/openliberty/guides/inventory/model/InventoryList.java` to `getCount()`.

[source, Java]
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/model/InventoryList.java[tags=**;!copyright;]
----

This will introduce a breaking change to the REST service because the response will have renamed properties after deployment.

Before version 2 is deployed:
```
{
    "systems": [],
    "total": 0
}
```

After version 2 is deployed:
```
{
    "systems": [],
    "count": 0
}
```


Therefore, any clients consuming the updated service will be broken since they are expecting a property called
`total` instead of `count`. Instead of running only the new service, both services can be run simultaneously.
The reason behind running both services is so that old clients do not have to upgrade to use the new api,
they can simply continue to use the old one.

Run this command to update the version of your service.

```
mvn versions:set -DnewVersion=2.0-SNAPSHOT
```

Navigate to the `start/inventory` directory and run the given command to rebuild the inventory service.
```
mvn clean package
```

Update the `kubernetes.yaml` file to add a new deployment for v2 of the inventory service.

[source, yaml]
----
include::finish/kubernetes.yaml[tags=**;!copyright;]
----

Notice the `version` labels we use to denote which deployment is for version 1 of the application and
which deployment is for version 2. This will give us the ability to select which version of the inventory
service to forward requests to.


Redeploy your services using the same commands from before.

Unix:
```
kubectl apply -f <(istioctl kube-inject -f kubernetes.yaml)
```

Windows:
```
istioctl kube-inject -f kubernetes.yaml > tmp.yaml
kubectl apply -f tmp.yaml
DEL tmp.yaml
```

You can see that version 2 of the inventory application has been deployed.
[source, role="no_copy"]
----
ingress "gateway" unchanged
service "inventory-service" unchanged
deployment "inventory-deployment-v1" configured
deployment "inventory-deployment-v2" created
service "system-service" unchanged
deployment "system-deployment" configured
----

Use the following curl command a few times to make multiple requests `curl http://ip-address:port/inventory/systems`

Observe that requests go to both v1 and v2. This is not what
a client consuming this service wants because it is unpredictable and the client would get
an incorrect response half of the time. To solve this you can use request routing to default
to version 1 and allow the client to access version 2 when specifically requested. This way,
existing client won't be broken and any new clients that would like to use v2 can easily
request it.


// =================================================================================================
// Configure request routing
// =================================================================================================

== Configure request routing

Create the file `routing.yaml` in the `start` directory:

[source, yaml]
----
include::finish/routing.yaml[tags=**;!copyright;]
----

The `routing.yaml` file routes incoming requests based on the uri prefix `/inventory` and a header
`x-version`. If the header has the value `v2`, then requests will be routed to the `v2` deployment and otherwise
the requests are routed to `v1` as to avoid breaking existing clients. In the `kubernetes.yaml` file we specified
some `version` labels, in this `routing.yaml` file we make use of the `version` label to route requests to the appropriate
deployment.

Apply your routing rules by running the given command.
```
istioctl create -f routing.yaml
```

Make a request `curl http://ip-address:port/inventory/systems -H "x-version: v2"`, observe that request goes to v2 of the service where you see "count".
Make a request `curl http://ip-address:port/inventory/systems`, observe that request default to v1 of the service where you see "total".


== Testing microservices that are running on {kube}

Create the following file `inventory/src/test/java/it/io/openliberty/guides/inventory/InventoryVersionTest.java`:
[source, Java]
----
include::finish/inventory/src/test/java/it/io/openliberty/guides/inventory/InventoryVersionTest.java[tags=**;!copyright;]
----

The tests verify that:
* If no `x-version` header is present then it defaults to version 1
* If `x-version` has value `v1` then it uses version 1
* If `x-version` has value `v2` then it uses version 2

Each test is repeated three times to ensure that it didn't pass by chance if the routing was not applied correctly.

Run the following command to start the tests:

```
mvn verify -Ddockerfile.skip=true -Dtest.ip=ip-address -Dtest.port=port
```

// =================================================================================================
// finish
// =================================================================================================

== Great work! You're done!

You have deployed to services to {kube} and routed requests to different versions of the `inventory` service based on
http headers.

// uncomment this when Istio guide is released
//Feel free to check out our https://github.com/OpenLiberty/guide-istio[Istio guide], which builds on top of what you learned here.

// Include the below from the guides-common repo to tell users how they can contribute to the guide
include::{common-includes}/finish.adoc[]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"

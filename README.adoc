// INSTRUCTION: Please remove all comments that start INSTRUCTION prior to commit. Most comments should be removed, although not the copyright.
// INSTRUCTION: The copyright statement must appear at the top of the file
//
// Copyright (c) 2017 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: istio
:page-layout: guide
:page-duration: 30 minutes
:page-releasedate: 2018-06-30
:page-description: Explore how to route traffic to different versions of the same service using Istio and Kubernetes.
:page-tags: ['microservices', '{kube}', 'Docker', 'containers', 'kubectl', 'Minikube', 'istio']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker', 'kubernetes']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
= Versioning services with Istio

Explore how to route traffic to different versions of the same service using Istio and Kubernetes.

:minikube-ip: 192.168.99.100
:kube: Kubernetes
:istio: Istio


== What you'll learn

You will learn how to deploy an application to a kubernetes cluster using {istio} and how to configure
{istio} to route http requests based on the content of the headers.

The two microservices that you will deploy are called `inventory` and `system`, they are provided for you under
the `start` directory. The `inventory` service stores information about systems that are running the `system` service.

You will use Minikube as your local {kube} cluster. You will use {istio}'s Ingress, and the `istioctl`
cli tool to deploy your application as well as configure the routing.

// =================================================================================================
// What is {istio}
// =================================================================================================

== What is {istio}?

{istio} is a platform that provides several features that allow you manage various aspects
of how your microservices interact with eachother and the outside world. It works by deploying
a few extra services and injecting an additional container into each of your pods that contains
the https://www.envoyproxy.io/[Envoy] proxy.

While {istio} supports {kube} and that will be the focus of this guide, please note that {istio}
can also be used with other environments.

=== Why use {istio}?

{istio} provides a collection of features that allow you to several aspects of your services
such as: Routing, Logging, and Security. These features can easily be enabled by applying the appropriate
{istio} files to your {kube} cluster. This guide will specifically focus on routing.

// =================================================================================================
// Prerequisites
// =================================================================================================

== Prerequisites

// Before you begin, make sure to have the following tools installed:

// - `kubernetes-cli` - a command line interface for {kube} called `kubectl`. This is your primary
// tool for communicating with and managing your {kube} cluster.
// - `kubernetes-helm` - a package manager for {kube} called Helm. Helm allows you to install packages
// or "charts", which are sets of preconfigured {kube} resources. Installing charts is much more
// convenient than creating and configuring the resources yourself.
// - `minikube` - a local, single-node {kube} cluster that runs in a virtual machine.

// Finally, you will need a containerization software for building containers. {kube} supports a variety
// of container types and while you're not limited to any of them in particular, you should use Docker
// as this is what this guide will focus on.


Before you being, make sure to have the following tools installed:

- `kubernetes-cli` - a command line interface for {kube} called `kubectl`. This is your primary
tool for communicating with and managing your {kube} cluster.
- `minikube` - a local, single-node {kube} cluster that runs in a virtual machine.
- `istioctl` - a command line interface for {istio} to deploy {istio} to your {kube} cluster
and to manage your {istio} configurations. Installation instructions can be found here:  https://istio.io/docs/setup/kubernetes/quick-start/

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.

// =================================================================================================
// Staring and preparing your cluster for Deployment
// =================================================================================================

== Starting and preparing your cluster for Deployment

You must start Minikube with these flags to use {istio}:

Unix:
```
minikube start \
    --extra-config=controller-manager.ClusterSigningCertFile="/var/lib/localkube/certs/ca.crt" \
    --extra-config=controller-manager.ClusterSigningKeyFile="/var/lib/localkube/certs/ca.key" \
    --extra-config=apiserver.Admission.PluginNames=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
```

Windows:
```
minikube start ^
    --bootstrapper=localkube ^
    --vm-driver=hyperv ^
    --hyperv-virtual-switch=minikube-virtual-switch ^
    --extra-config=controller-manager.ClusterSigningCertFile="/var/lib/localkube/certs/ca.crt" ^
    --extra-config=controller-manager.ClusterSigningKeyFile="/var/lib/localkube/certs/ca.key" ^
    --extra-config=apiserver.Admission.PluginNames=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
```

Run this command to connect the Docker CLI to use Minikube's Docker Daemon:

Bash:
```
eval $(minikube docker-env)
```

Windows:
```
minikube docker-env > tmp.cmd && call tmp.cmd && DEL tmp.cmd
```

Next, you must deploy {istio} to your cluster. From the directory where you installed {istio}, run the following command:
```
kubectl apply -f install/kubernetes/istio.yaml
```
If you observe any errors, run the command one more time and it should succeed without any errors.

You can verify that it was successful by running the following command to ensure that {istio} was deployed:
```
kubectl get pods -n istio-system
```
 
You can verify when the istio pods are all ready:
[source, role="no_copy"]
----
NAME                             READY     STATUS    RESTARTS   AGE
istio-ca-75fb7dc8d5-zv5km        1/1       Running   0          2m
istio-ingress-577d7b7fc7-tggs6   1/1       Running   0          2m
istio-mixer-859796c6bf-4j6nv     3/3       Running   0          2m
istio-pilot-65648c94fb-9pnpr     2/2       Running   0          2m
----

// =================================================================================================
// Deploying v1 of the services to cluster
// =================================================================================================

== Deploying version 1 of the services to cluster

Navigate to the `start` directory and run the following command, it may take a few minutes to build:
```
mvn clean package
```

To deploy the services to the {kube} cluster, run the following commands:

Bash:
```
kubectl apply -f <(istioctl kube-inject -f kubernetes.yaml)
```

Windows:
```
istioctl kube-inject -f kubernetes.yaml > tmp.yaml
kubectl apply -f tmp.yaml
DEL tmp.yaml
```

This will inject the sidecar containers into your configuration so that the Envoy proxy
is deployed with each of your pods.

You can see that your resources are created after running the `kubectl apply -f ...` command:
[source, role="no_copy"]
----
ingress "gateway" created
service "inventory-service" created
deployment "inventory-deployment-v1" created
service "system-service" created
deployment "system-deployment" created
----

To get the base url, use the following command:
```
minikube service list | grep istio-ingress
```

This command will give you a url of the form `http://ip-address:port`.

Once all the pods are started, you should be able to navigate to `http://ip-address:port/inventory/systems` to view
v1 of the deployed application.

// =================================================================================================
// Modify the service
// =================================================================================================

== Modify and deploy version 2 of the service

Rename the `getTotal()` method in `inventory/src/main/java/io/openliberty/guides/inventory/model/InventoryList.java` to `getCount()`:

[source, Java]
----
include::finish/inventory/src/main/java/io/openliberty/guides/inventory/model/InventoryList.java[tags=**;!copyright;]
----

This introduces a breaking change to the REST service because now the response will look like:
```
{
    "systems": [],
    "count": 0
}
```

instead of:

```
{
    "systems": [],
    "total": 0
}
```

Therefore, any clients consuming the service will now be broken since they are expecting a property called
`total` instead of `count`. To solve this, we can actually have both versions of the service deployed
and decide which one to use by having a header distinguish which version to use.

To update the version of your service, run the following command:

```
mvn versions:set -DnewVersion=2.0-SNAPSHOT
```

Rebuild the service by navigating to the `start/inventory` directory and running the following command:
```
mvn clean package
```

Update the `kubernetes.yaml` file to add a new deployment for v2 of the inventory service:

[source, yaml]
----
include::finish/kubernetes.yaml[tags=**;!copyright;]
----

Redeploy your services using the following commands:

Bash:
```
kubectl apply -f <(istioctl kube-inject -f kubernetes.yaml)
```

Windows:
```
istioctl kube-inject -f kubernetes.yaml > tmp.yaml
kubectl apply -f tmp.yaml
DEL tmp.yaml
```

You can see that version 2 of the inventory application has been deployed:
[source, role="no_copy"]
----
ingress "gateway" unchanged
service "inventory-service" unchanged
deployment "inventory-deployment-v1" configured
deployment "inventory-deployment-v2" created
service "system-service" unchanged
deployment "system-deployment" configured
----

Make a request to the service and observe that requests go to both v1 and v2.

// =================================================================================================
// Configure request routing
// =================================================================================================

== Configure request routing

Create the file `routing.yaml` in the `start` directory:

[source, yaml]
----
include::finish/routing.yaml[tags=**;!copyright;]
----

The `routing.yaml` file routes incoming requests based on the uri prefix `/inventory` and a header
`x-version`. If the header has the value `v2`, then requests will be routed to the `v2` deployment and otherwise
the requests are routed to `v1` as to avoid breaking existing clients.

To apply your routing rules, run the following command:
```
istioctl create -f routing.yaml
```

Make a request `curl http://ip-address:port/api/name -H "x-version: v2"`, observe that request goes to v2 of the service.
Make a request `curl http://ip-address:port/api/name`, observe that request default to v1 of the service.


== Testing microservices that are running on {kube}

Create the following file `inventory/src/test/java/it/io/openliberty/guides/inventory/InventoryVersionTest.java`:
[source, Java]
----
include::finish/inventory/src/test/java/it/io/openliberty/guides/inventory/InventoryVersionTest.java[tags=**;!copyright;]
----

The tests verify that:
* If no `x-version` header is present then it defaults to version 1
* If `x-version` has value `v1` then it uses version 1
* If `x-version` has value `v2` then it uses version 2

Run the following command to start the tests:

```
mvn verify -Ddockerfile.skip=true -Dtest.ip=ip-address -Dtest.port=port
```

// =================================================================================================
// finish
// =================================================================================================

== Great work! You're done!

You have deployed to services to {kube} and routed requests to different versions of the `inventory` service based on
http headers.

// uncomment this when Istio guide is released
//Feel free to check out our https://github.com/OpenLiberty/guide-istio[Istio guide], which builds on top of what you learned here.

// Include the below from the guides-common repo to tell users how they can contribute to the guide
include::{common-includes}/finish.adoc[]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"

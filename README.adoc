// INSTRUCTION: Please remove all comments that start INSTRUCTION prior to commit. Most comments should be removed, although not the copyright.
// INSTRUCTION: The copyright statement must appear at the top of the file
//
// Copyright (c) 2017 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: istio
:page-layout: guide
:page-duration: 30 minutes
:page-releasedate: 2018-06-30
:page-description: Explore how to route traffic to different versions of the same service using Istio and Kubernetes.
:page-tags: ['microservices', '{kube}', 'Docker', 'containers', 'kubectl', 'Minikube', 'istio']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker', 'kubernetes']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
= Routing traffic with Istio

Explore how to route traffic to different versions of the same service using Istio and Kubernetes.

:minikube-ip: 192.168.99.100
:kube: Kubernetes
:istio: Istio


== What you'll learn

You will learn how to deploy an application to a kubernetes cluster using {istio} and how to configure
{istio} to route http requests based on the content of the headers.

The two microservices that you will deploy are called `name` and `ping`, they are provided for you under
the `start` directory. The `name` service displays a brief gretting, and the `ping` microservice pings the
`name` service. You will modify the name service so that it can easily be configured to display
a different greeting.

You will use Minikube as your local {kube} cluster. You will use {istio}'s Ingress, and the `istioctl`
cli tool to deploy your application as well as configure the routing.

// =================================================================================================
// What is {istio}
// =================================================================================================

== What is {istio}?

{istio} is a platform that provides several features that allow you manage various aspects
of how your microservices interact with eachother and the outside world. It works by deploying
a few extra services and injecting an additional container into each of your pods that contains
the https://www.envoyproxy.io/[Envoy] proxy.

While {istio} supports {kube} and that will be the focus of this guide, please note that {istio}
can also be used with other environments.

=== Why use {istio}?

{istio} provides a collection of features that allow you to several aspects of your services
such as: Routing, Logging, and Security. These features can easily be enabled by applying the appropriate
{istio} files to your {kube} cluster. This guide will specifically focus on routing.

// =================================================================================================
// Prerequisites
// =================================================================================================

== Prerequisites

// Before you begin, make sure to have the following tools installed:

// - `kubernetes-cli` - a command line interface for {kube} called `kubectl`. This is your primary
// tool for communicating with and managing your {kube} cluster.
// - `kubernetes-helm` - a package manager for {kube} called Helm. Helm allows you to install packages
// or "charts", which are sets of preconfigured {kube} resources. Installing charts is much more
// convenient than creating and configuring the resources yourself.
// - `minikube` - a local, single-node {kube} cluster that runs in a virtual machine.

// Finally, you will need a containerization software for building containers. {kube} supports a variety
// of container types and while you're not limited to any of them in particular, you should use Docker
// as this is what this guide will focus on.


Before you being, make sure to have the following tools installed:

- `kubernetes-cli` - a command line interface for {kube} called `kubectl`. This is your primary
tool for communicating with and managing your {kube} cluster.
- `minikube` - a local, single-node {kube} cluster that runs in a virtual machine.
- `istioctl` - a command line interface for {istio} to deploy {istio} to your {kube} cluster
and to manage your {istio} configurations. Installation instructions can be found here:  https://istio.io/docs/setup/kubernetes/quick-start/

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.

// =================================================================================================
// Modifying the name service to display a customized message
// =================================================================================================

== Modifying the name service to display a customized message

Modify the file `start/name/src/main/java/io/openliberty/guides/name/NameResource`, to contain the following contents:

[source, Java]
----
include::finish/name/src/main/java/io/openliberty/guides/name/NameResource.java[tags=**;!copyright;]
----

This will allow you to customize the message by creating an environment variable named `GREETING` inside of your container.


// =================================================================================================
// Staring and preparing your cluster for Deployment
// =================================================================================================

== Starting and preparing your cluster for Deployment

You must start Minikube with these flags to use {istio}:

```
# Unix
minikube start \
    --extra-config=controller-manager.ClusterSigningCertFile="/var/lib/localkube/certs/ca.crt" \
    --extra-config=controller-manager.ClusterSigningKeyFile="/var/lib/localkube/certs/ca.key" \
    --extra-config=apiserver.Admission.PluginNames=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota

# Windows
minikube start ^
    --bootstrapper=localkube ^
    --vm-driver=hyperv ^
    --hyperv-virtual-switch=minikube-virtual-switch ^
    --extra-config=controller-manager.ClusterSigningCertFile="/var/lib/localkube/certs/ca.crt" ^
    --extra-config=controller-manager.ClusterSigningKeyFile="/var/lib/localkube/certs/ca.key" ^
    --extra-config=apiserver.Admission.PluginNames=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
```

Run this command to connect the Docker CLI to use Minikube's Docker Daemon:
```
# From Bash if you're on Linux or MacOS
eval $(minikube docker-env)
# From PowerShell or CMD if you're on Windows
minikube docker-env > tmp.cmd && call tmp.cmd && DEL tmp.cmd
```

Next, you must deploy {istio} to your cluster. From the directory where you installed {istio}, run the following command:
```
kubectl apply -f install/kubernetes/istio.yaml
```
If you observe any errors, run the command one more time and it should succeed without any errors.

You can verify that it was successful by running the following command to ensure that {istio} was deployed:
```
kubectl get pods -n istio-system
```

// =================================================================================================
// Building and containerizing the microservices
// =================================================================================================

== Building and containerizing the microservices

To build Docker images for your services run the following command from the `start` directory:

```
mvn package
```

// =================================================================================================
// Deploying services to cluster
// =================================================================================================

== Deploying services to cluster

First, create a file called `kubernetes.yaml` in the `start` directory:

[source, yaml]
----
include::finish/kubernetes.yaml[tags=**;!copyright;]
----

Add description of what resources this file will create when deployed.

To deploy the services to the {kube} cluster, run the following commands:
```
# Unix
kubectl apply -f <(istioctl kube-inject -f kubernetes.yaml)
# Windows
istioctl kube-inject -f kubernetes.yaml > tmp.yaml
kubectl apply -f tmp.yaml
DEL tmp.yaml
```

This will inject the sidecar containers into your configuration so that the Envoy proxy
is deployed with each of your pods.

Once all the pods are started, you should be able to navigate to http://tbd:port/api/name
and view a different greeting whenever you refresh the page. This is because by default it will
route traffic to either pod arbitrarily.

Next, create the following file in the `start` directory:

[source, yaml]
----
include::finish/routing.yaml[tags=**;!copyright;]
----

Add description of what each of the routing rules do.

Now if you navigate to the same page on Chrome, you will see a Chrome specific message, and if you
navigate to it on Firefox you will see a Firefox specific message. If you navigate to the page from
any other browser it will simply display a generic greeting.

// =================================================================================================
// Testing microservices that are running on {kube}
// =================================================================================================

== Testing microservices that are running on {kube}

A few tests are included for you to test the basic functionality of the microservices. If a test failure
occurs, then you might have introduced a bug into the code. To run the tests, wait for all Pods to be
in the ready state, then run the `mvn verify` command with the following list of properties:

[cols="15, 100", options="header"]
|===
| *Property*        | *Description*
| cluster.ip        | IP address of your Minikube cluster, `{minikube-ip}` by default.
| name.ingress.path | Ingress path of the `name` microservice, `/name` by default.
| ping.ingress.path | Ingress path of the `ping` microservice, `/ping` by default.
| name.kube.service | Name of the {kube} Service wrapping the `name` Pods, `ol-name-ibm-open-liberty` by default.
| name.node.port    | Node port of the {kube} Service wrapping the `name` Pods. Set this if you didn't
setup an Ingress.
| ping.node.port    | Node port of the {kube} Service wrapping the `ping` Pods. Set this if you didn't
setup an Ingress.
|===

For example:

```
mvn verify -Ddockerfile.skip=true
```

This command will run integration tests with all default properties. The `dockerfile.skip` parameter
is set to `true` in order to skip building a new Docker image.

Alternatively, if you didn't setup an Ingress, you can use set the `name.node.port` and `ping.node.port`
properties like so to make requests through your {kube} Services instead:

```
mvn verify -Dname.node.port=<name-node-port> -Dping.node.port=<ping-node-port> -Ddockerfile.skip=true
```

If the tests pass, you'll see an output similar to the following for each service respectively:

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.name.NameEndpointTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.673 sec - in it.io.openliberty.guides.name.NameEndpointTest

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.ping.PingEndpointTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.222 sec - in it.io.openliberty.guides.ping.PingEndpointTest

Results :

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
----


// =================================================================================================
// Editing {kube} resources
// =================================================================================================

== Optional: Editing {kube} resources

While you don't need to edit any of the {kube} resources in this guide, it might be helpful for
you to know how this is done for any future projects that you have in mind.

To make changes to a {kube} resource, you can either edit that resource's whole YAML file in a text
editor or update particular parts of the YAML with the `kubectl` command.

=== Direct editing

Resource YAML files can be directly edited from the {kube} dashboard or a text editor of your choice.

To edit a resource from the Minikube dashboard, run the `minikune dashboard` command to open the Minikube
dashboard, then use the left navigational panel to select which resources to edit.

To open and edit a resource in a text editor, run the `kubectl edit (RESOURCE/NAME | -f FILENAME) [options]`
command, specifying the resource type and its name. Once you save your changes, they will be automatically
picked up and applied to your resource.

If you didn't create resources through charts, but rather implemented and created them yourself from
YAML files by using the `kubectl create` command, then you can edit these YAMLs directly and then
reapply them by running the `kubectl apply -f [FILENAME] options` command.

To familiarize yourself with resource editing, edit the `ol-name-ibm-open-liberty` Ingress and change
the `path` field in the `spec` object from `/name` to `/myname`. Use any editing method you prefer:

[source, YAML]
----
{
  "kind": "Ingress",
  "apiVersion": "extensions/v1beta1",
  "metadata": {
    "name": "ol-name-ibm-open-liberty",
    "namespace": "default",
    "selfLink": "/apis/extensions/v1beta1/namespaces/default/ingresses/ol-name-ibm-open-liberty",
    "uid": "18353cff-5fc5-11e8-af4d-08002784f87f",
    "resourceVersion": "64202",
    "generation": 1,
    "creationTimestamp": "2018-05-25T02:41:15Z",
    "labels": {
      "app": "ol-name-ibm-open-liberty",
      "chart": "ibm-open-liberty-1.2.0",
      "heritage": "Tiller",
      "release": "ol-name"
    },
    "annotations": {
      "kubernetes.io/ingress.class": "nginx",
      "nginx.ingress.kubernetes.io/affinity": "cookie",
      "nginx.ingress.kubernetes.io/rewrite-target": "/api/name",
      "nginx.ingress.kubernetes.io/session-cookie-hash": "sha1",
      "nginx.ingress.kubernetes.io/session-cookie-name": "route"
    }
  },
  "spec": {
    "rules": [
      {
        "http": {
          "paths": [
            {
              "path": "/myname",
              "backend": {
                "serviceName": "ol-name-ibm-open-liberty",
                "servicePort": 9080
              }
            }
          ]
        }
      }
    ]
  },
  "status": {
    "loadBalancer": {
      "ingress": [
        {
          "ip": "10.0.2.15"
        }
      ]
    }
  }
}
----

When you're done editing, visit the new Ingress endpoint to verify that your changes have been applied.


=== Indirect editing

Indirect editing of resources can be done by using various `kubectl` commands. If you recall,
you've already done this when you ran `kubectl set image` to update the image used by your Deployment
to a newer version. `kubectl set` is convenient, but its limited to a small set of fields that you can
change. Sometimes you might need to change parts of a resource that the `kubectl set` command simply
doesn't cover. In those cases and as an alternative to the `kubectl set` command, you can use the
`kubectl patch (-f FILENAME | TYPE NAME) -p PATCH [options]` command to make updates using strategic
merging. The `kubectl patch` command works by supplying a piece of config in a form of a JSON or a YAML
that matches another piece of similar config in the resource and overrides the fields that don't match.
For example, to change the Ingress path from `/name` to `/myname` as in the previous section, run the
following command:

```
# From Bash if you're on Linux or MacOS
kubectl patch ingress/ol-name-ibm-open-liberty -p '{"spec": {"rules": [{"http": {"paths": [{"path": "/myname", "backend": {"serviceName": "ol-name-ibm-open-liberty", "servicePort": 9080}}]}}]}}'
# From PowerShell or CMD if you're on Windows
kubectl patch ingress/ol-name-ibm-open-liberty -p "{\"spec\": {\"rules\": [{\"http\": {\"paths\": [{\"path\": \"/myname\", \"backend\": {\"serviceName\": \"ol-name-ibm-open-liberty\", \"servicePort\": 9080}}]}}]}}"
```

{kube} will match your config pattern against the `spec` object defined in the `ol-name-ibm-open-liberty`
Ingress and override the `path` field.


// =================================================================================================
// finish
// =================================================================================================

== Great work! You're done!

You have just deployed two microservices to {kube} using Helm charts. You then scaled a microservice,
rolled out deployment updates, ran integration tests against miroservices that are running in a {kube}
cluster, and learned how to edit {kube} resources.

// uncomment this when Istio guide is released
//Feel free to check out our https://github.com/OpenLiberty/guide-istio[Istio guide], which builds on top of what you learned here.

// Include the below from the guides-common repo to tell users how they can contribute to the guide
include::{common-includes}/finish.adoc[]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"
